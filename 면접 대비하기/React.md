# 리액트란?

리액트란 UI를 만들기 위한 JavaScript 라이브러리입니다. 특징으로는 UI를 재사용 가능한 작은 조각인 컴포넌트로 구성하였고, 가상 돔을 통해 DOM을 더욱 효율적으로 관리하고자 하였습니다.

# 가상 돔이란?

리액트는 문서의 동적인 변화에 대해서 실제로 돔을 바로 제어하는 것이 아니라, 돔의 복제본인 가상 돔을 만들고 JavaScript가 실행되는 메모리에서 관리하도록 하였습니다. 이를 통해, 돔 업데이트가 실제로 필요한 부분만 계산하여 브라우저의 렌더링 프로세스를 최적화하고자 하였습니다. 또한, 개발자가 UI 업데이트나 렌더링에 대한 부분을 생각하지 않도록 편의성을 제공하였습니다.

## 가상 돔이 어떻게 업데이트할 돔만 계산하나요?

이에 대한 계산은 비교를 통해서 이뤄집니다. 가상 돔은 UI의 상태가 변경되면, 새로운 가상 돔을 하나 더 만들고 이전의 가상 돔과 비교하여 어떤 부분만 업데이트해야 하는지를 판단할 수 있습니다.

# 컴포넌트란 무엇인가요?

UI를 재사용 가능한 독립적인 작은 조각들로 나눈 것입니다.
독립적이기에 각 컴포넌트는 상태들을 가질 수 있고, props를 통해서 부모 컴포넌트로부터 데이터나 상태를 공유할 수 있습니다.
또한, 재사용 가능하기에 어떤 페이지에서 사용한 컴포넌트를 언제 어디서나 컴포넌트를 다른 컴포넌트나 독립적으로 다시 사용할 수 있습니다.

이를 통해서 UI를 위한 코드를 서로 분리하여 코드의 가독성이나 재사용성을 높이고자 하였습니다.

# 클래스 컴포넌트와 함수 컴포넌트의 차이

컴포넌트를 만드는 방법 등의 차이도 있겠지만, 가장 큰 차이점은 상태와 라이프 사이클을 관리하는 주체가 클래스인가 아니먄 리액트 자체인가라고 생각합니다.
클래스 컴포넌트는 상태를 관리하는 주체가 리액트 라는 클래스를 상속받은 클래스 컴포넌트 자체였지만, 함수 컴포넌트에서는 리액트 훅을 사용하여 리액트 자체에서 관리합니다.

# 리액트에서 상태를 관리하는 방법

리액트에서는 useState를 통해서 상태를 관리할 수 있는데, 먼저 이 함수의 리턴은 배열형태인데, 현재 상태를 확인할 수 있는 0번째 인덱스와 이 상태를 업데이트할 수 있는 dispatch함수인 1번째 인덱스를 리턴합니다.

리액트는 클로저를 사용해서 상태를 관리하고 추적합니다. 리액트 자체에서 관리하고 있는 배열에 useState가 실행될때마다 추적해야할 상태를 추가합니다.

해당 인덱스의 상태를 업데이트하고 리액트를 트리거하는 것이 useState의 반환 값 중 하나인 dispatch함수이며, 이는 클로저를 사용하여 해당 주소를 가리키도록 되어있습니다.

# 리액트 18의 주요 변경점

크게 3가지라고 생각합니다.

오토 배칭, 동시성 문제 해결 같은 것들도 있지만 크게 2가지라고 생각합니다.
Suspense나 use 훅 같은 비동기에 대한 일급 지원 추가, 서버 컴포넌트 도입입니다.

Suspense를 사용해서, 컴포넌트 렌더링 중에 throw된 promise를 만나게 되면, fallback에 들어간 컴포넌트가 렌더링되더가 해당 promise가 resolve될 때 다시 렌더링을 시도하는 방식을 통해서 개발자가 useEffect와 상태를 통한 조건부렌더링을 통해 loading에 대한 ui 핸들링을 더욱 편하게 해주었습니다.
use 훅을 통해서 클라리언트 컴포넌트에서 async/await와 같이 use를 만나면 렌더링이 중단되어 해당 promise가 이행될 때까지 기다리는 훅도 추가하였습니다.

서버 컴포넌트를 통해서 서버에서만 작동하여, 미리 html 문서를 만들어 오는 것입니다. 3가지 특징이 있습니다.

훅을 사용할 수 없고, 이벤트리스너와 함수를 props로 전달할 수 없고, 클라이언트 컴포넌트의 번들 파일에 서버 컴포넌트는 묶이지 않습니다.
