뭔가 프론트엔드에서는 리액트가 디자인 패턴을 알아서 적용해놨고, 리액트의 컨벤션을 따르면 디자인 패턴을 따르게 된다고 막연하게 생각하고 미뤄왔는데, 면접에서 물어보신 걸 보니까 필요한 것 같다.

# 디자인 패턴, 아키텍쳐, 프로그래밍 패러다임

이 3가지의 차이에 대해서 생각하고 여러가지 계속 찾아봤는데, 다들 이야기하는 것도 다르다. 1+1 = 2 마냥 정해진 정답이 없는 것 같다..

## 아키텍쳐

아키텍처는 하나의 프로젝트를 이루는 시스템 전체의 디자인과 구조를 뜻한다. 아키텍쳐의 예시 중 하나가 바로 `Client-Server 아키텍쳐`이다.

즉, 아키텍쳐는 하나의 어플리케이션이나 하나의 프로그램 전체를 이루는 동작을 말한다. 아키텍쳐를 논할 때, 클라이언트의 리액트 컴포넌트를 어떤 구조로 나누고 어떻게 할지 이야기하지 않는다.

유저가 우리 서버에 도착했을 때, 이를 요청에 맞게 서빙해줄 웹 서버를 무엇으로 구성할 것인가도 생각해야한다. 이를 클라우딩 컴퓨팅을 사용할지, 직접 컴퓨터를 사용할지도 생각하고, 어떤 회사의 클라우딩 컴퓨팅을 사용해야할지도 생각해야한다.

이렇듯 하나의 프로젝트를 이루는 시스템 전체에 대한 설계가 바로 아키텍쳐이다. 이밖에도 `MSA 아키텍쳐` 같은 것들도 있다.

## 디자인 패턴

이건 코드를 어떻게 구성하고 작성해나갈 것인가에 대한 디자인을 패턴화한 것이다. 함수의 목적을 정의하고 어떤 단위로 모듈화할 것인가? 를 다루는 것이 디자인 패턴이다.

## 프로그래밍 패러다임

소프트웨어를 개발하는 데 사용되는 기본적인 접근 방식 또는 철학을 의미한다. 절차지향, 객체지향, 함수형 프로그래밍이 있는데, 이들은 결국 어떤 파일의 로직을 구성하는데 있어서 어떻게 로직을 구성할 것인가이다.

## 3개의 차이

아키텍쳐는 시스템 전체를 아우르는 것이고, 웹에서는 서버와 클라이언트 구조를 가지고 각자 어떤 기술들을 사용할 것인가, 웹 서버는 어떻게 구성할 것인가 등을 이야기하는 것이다.

디자인 패턴은 전체의 시스템 중 하나의 시스템에서, 어떻게 모듈화하고 어떻게 구조를 가질 것인가를 말하는 것이다.

프로그래밍 패러다임은 어떤 함수나 로직을 작성할 때, 어떻게 작성할 것인가를 말하는 것이다. 절차지향적으로 순서에 맞게 작성할 것인가, 함수형 프로그래밍을 통해 불변성과 콜백함수를 사용할 것인가 등을 결정하는 것이다.

<br />

# 디자인 패턴

1.  MVC 패턴

    M(Model), V(View), C(Controller)라는 3가지 영역으로 나눠서 프로그래밍하고자 하는 것

    - Model

      데이터가 존재하는 곳이다. 이는 Database뿐만이 아니라, 여러 곳에서 나타날 수 있다. React의 전역 상태를 관리하고 있는 Context API나 Redux 등도 Model이고, HTTP API 응답이 Model이고, DB도 Model이다.

    - View

      보이는 부분인 화면을 의미한다. FE에서는 HTML과 CSS를 통한 웹 문서이다.

    - Controller

      View에서 유저의 입력을 받아서 Model을 바꾸거나, Model의 변화를 View에 반영하는 것을 말한다.
      <br />

    이렇게 나눈 이유는

    > 1. 화면을 다루는 문제와 데이터를 다루는 문제의 성격이 달라서 분리하고 싶고
    > 2. Model과 View간의 의존관계를 최소화 해서 화면의 수정이 데이터수정에 영향을 미치지 않고 데이터 수정이 화면의 수정에 영향을 미치지 않고자 함입니다.

    출처 : [테오 블로그](https://velog.io/@teo/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EC%97%90%EC%84%9C-MV-%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94)

    여기서 JQuery는 Model이 API의 응답이었다. 이를 Model로 활용하고, JavaScript를 사용해서 웹 문서를 마크업하는 것이 바로 JQuery였다.

<br />

2.  MVVM 패턴

    View를 다루는 Model인 View Model을 적용하는 것

    View, Model은 MVC와 같다.

    - View Model

      View를 표현하기 위해 만든 View를 위한 Model입니다. View를 나타내 주기 위한 Model이자 View를 나타내기 위한 데이터 처리를 하는 부분입니다.

    JQuery의 Model과 관련하여 보일러 플레이트가 많이 발생했다. 계속해서 데이터를 받고 -> 무언가를 하고가 반복되었고, 필요한 부분의 HTML 요소만을 직접 가져오고 다뤄야했다.

    그 와중에 `Angular.js`가 등장했다. 프론트엔드 단에서 템플릿과 바인딩이라는 개념이 처음 등장했다. 그러면서, JQuery는 DOM 요소를 직접 가져오고 이벤트를 추가하던가 했던 **직접 구현**에서 **선언적 방법**으로 진화하였다.

    > 이제는 코드에서 DOM을 조작하는 코드가 사라지고 이 기능들은 프레임워크가 담당하게 됩니다. 이제 개발자는 화면에 그려져야할 데이터만 만들어서 프레임워크에 전달해주면 프레임워크가 알아서 그려줍니다.

    출처 : [테오 블로그](https://velog.io/@teo/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EC%97%90%EC%84%9C-MV-%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94)

<br />

3. Container-Presenter 패턴

   MVVM 패턴의 등장과 이를 활용할 수 있는 프레임워크들로 인해서 웹 프론트엔드는 발전하게 된다.

   더욱이 ES6+ 문법의 등장으로 인해서 웹에서도 import를 통해 모듈을 사용할 수 있게 되었고, 하나의 웹 페이지를 이루는 코드들을 모듈화할 수 있게 되었다.

   > 그래서 MVVM이 이제 화면단위가 아니라 조금 더 작게 재사용 할 수 있는 단위로 만들어서 조립을 하는 방식으로 발전을 하게 됩니다.

   이것이 컴포넌트이다.

   비즈니스 로직을 담당하는 Container Component와 데이터만 뿌려주는 Presenter 컴포넌트로 분리하는 것이 Container-Presenter 패턴이다.

   여기서 props의 개념이 등장한다. 그런데, 컴포넌트가 복잡해질수록 컴포넌트 간의 구성 거리가 큰 상황에서 props로 데이터를 전달하려면 props를 전달하기만하는 반복이 등장하였는데, 이것이 바로 `props drilling`이다.

<br />

4. FLUX 패턴

   이를 해결하기 위해 나타난 것이 Flux 패턴이다. Flux 패턴은 MVC 패턴에서 벗어나, 단방향 데이터 흐름을 가지는 아키텍쳐를 만들고자 한 결과이다.

   ![image](https://github.com/vinitus/TIL/assets/97886013/8e01c4a6-f063-4f85-a22d-ad73db40bc48)

   MVC는 이렇게 Model과 View 간의 데이터를 전달하기 위한 양방향 데이터 흐름은 관리하기 매우 어렵고, 예기치 못한 버그를 만든다고 하였다.

   실제로 페이스북의 버그 중에, 알림창에 대한 버그가 있었다. 우측 상단에 새로운 메세지 알림이 뜨는데, 이를 메시지 함을 확인해보면 아무것도 없다. 확인을 하면 결국에는 알림이 사라지지만, 몇 분 뒤 알림이 다시 나타나고 여전히 메시지가 없는 버그이다.

   이를 겪은 페이스북 팀은, MVC 패턴은 너무 빠르게 복잡해진다고 하였다. 그리고 이를 해결하기 위해서, Flux 패턴을 도입하여 데이터의 흐름이 단방향으로 흘러가게 하고자 했다.

   ![image](https://github.com/vinitus/TIL/assets/97886013/590e4be1-c670-46ad-af20-0f7a1d981247)

   Dispatcher를 통해서만 데이터가 저장되는 store에 접근할 수 있게 함으로써, 데이터를 변경하는 작업을 하나의 흐름으로만 동작하게 하였고, 해당 동작을 트리거하는 것을 action으로 지정했다.

   - Action : View단의 상호작용으로 인해서 시작되며, 데이터를 변경하는 일련의 작업이 시작되는 것이다. Dispatcher에 Action 메시지를 보낸다.

   - Dispatcher : Action에 대한 정보를 받아서 실제로 어떤 행동을 할 지 결정되는 곳이며, 모든 데이터 흐름을 관리한다. Store에 접근하여 데이터를 변경한다.

   - Store : 데이터 저장소이다. 여기의 데이터는 Dispatcher에서만 접근하고 변경할 수 있으며, View는 데이터만 제공한다.

   이를 적용한 것 -> `Redux`

### reference

[https://help-solomon.tistory.com/16](https://help-solomon.tistory.com/16)
[https://velog.io/@teo/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EC%97%90%EC%84%9C-MV-%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94](https://velog.io/@teo/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EC%97%90%EC%84%9C-MV-%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94)
[https://beomy.tistory.com/43](https://beomy.tistory.com/43)
