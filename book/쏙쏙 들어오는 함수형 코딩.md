마크다운 기능을 완성하면서, 이것저것 생각하면서 다시 코드를 적어가다보니 이 책이 이제는 이해갈 것 같아서 읽기 시작 8/29 ~

원래는 나는 코드를 길게 만들면서, 그리고 함수를 이것저것 실행해가며 콜 스택을 어지럽히는게 과연 무엇이 좋을까? 성능적으로도 별로지 않을까? 생각했다.

그러디 FormFilter 컴포넌트의 로직과 백틱 알고리즘을 구현하면서 이제는 왜 사용해야하는지를 알게 될 것 같다.

이 마크다운 파일에서는 책의 정리보다는 내가 느끼고 찾아본 것들이 주류가 될 것 같다.

# 함수형 프로그래밍

함수형 프로그래밍에서는 수학적 함수인 순수 함수가 주류가 된다. 늘 언제나 같은 값을 받으면, 같은 결과가 나와야하는 것이다.

이를 프로그래밍으로 끌고온다면, 전역 변수를 사용하지 않아야 한다. 어떤 곳에서든 호출하면 언제나 같은 결과가 나와야한다. 이를 위해서는 부수 효과들을 빼야한다. `React`에서도 서버의 데이터를 받아오는 등의 행위를 useEffect 훅으로 묶어서 side effect(부수 효과)로 처리하고 컴포넌트 자체는 상태와 UI만을 위한 함수로 작동한다. 이처럼, 순수 함수도 side effect를 피하려고 한다.

하지만, 지금 말하려는 함수형 프로그래밍은 실제 프로덕션에서 사용하는 프로그래밍 패러다임 중 하나이다. 이는 반드시 side effect들이 포함되어야만 한다. 예를 들어 DB의 데이터를 읽어온다거나, HTTP 요청을 보내는 등의 작업이 side effect에 포함된다.

그래서 사전적 정의와 프로그래머가 사용하는 프로그래밍 패러다임으로써의 함수형 프로그래밍은 조금 다르다. side effect를 없앨 수 없기에 조심히다루고, 로직으로 부터 분리해낼 수 있는 순수 함수들을 분리하는 방식이 함수형 프로그래밍이다.

## 액션, 계산, 데이터

나는 처음 이 부분을 읽을 때, 왜 이렇게 나누는지 공감이 잘 되지 않았다. 액션을 최대한 분리하는 것이 무엇이 의미가 있을까? 액션이 계산을 오염시킨다고 해서 문제가 될게 있을까? 싶었다.

하지만 이제는 알 것 같다. 백틱 알고리즘을 테스트할 때, 여러 테스트 케이스들을 마크다운에 적고 실제로 적용해가며 테스트한 적이 있다. 그런데 나는 이제 하나의 함수에 반복문이나, 조건문들을 중첩하고 넣다보니 어디서 잘못된 방향으로 흘러가는지 몰라서 console.log를 10줄은 넘게 작성했던 것 같다.

그리고 리팩토링이 쉽다는 말은, 이미 여러 번의 함수형 프로그래밍이 아닌 직접 구현으로써 react프로젝트를 겪으며 느꼈던 것이다.

**전역 변수 사용에 대한 경고**

내가 이해한 책의 권고사항은, 외부 스코프를 참조하지 않는 것을 권하고 있다. 최대한 순수 함수로써 작성하라는 것이다. 처음에는 잘 이해가 가지 않았다. 적절하게 사용하면 이만큼 편한게 없는데?
그런데 이 부분을 읽고 컴포넌트를 리팩토링했던 일이 생각났다. 컴포넌트 안에서 어떤 함수를 만듬으로 인해서, 그 함수에서는 자연적으로 잘 사용했던 state나 setState들을 자연스럽게 사용했고 문제는 없었다. 그러다가 함수를 밖으로 빼내고, 상태를 관리하는 것을 props로 옮겨야했던 일이 있었다. 이때 좀 고생했던 기억이 난다. 귀찮더라도 함수들을 순수 함수로써 잘 했었다면 더 쉽고 편했을 것이다.

## 항상 인자를 받은 데이터를 복사해서 사용하기

이것도 처음에는 잘 이해가 가지 않았다. 이것도 근데 eslint에서 유명한 약속 중 하나이다. `no-param-reassign`

인자로 받은 데이터를 재할당하는 것은 코드의 가독성이나 유지보수에 좋지 않다. 그리고 만약, 이 인자를 그대로 사용해야만 하는 코드가, 재할당 이후에 이뤄진다면 코드를 어떻게 해야할지 충분히 문제가 될 수 있다고 생각한다.

그리고 원치 않는 문제가 생길 수 있다.

그나마 문제가 될만한 코드?

```javascript
const nums = [[1, 2, 3], [4, 5], [6]];

console.log(nums.flatMap((a) => a)); // [1, 2, 3, 4, 5, 6]

function fn(arr) {
  for (let i = 0; i < arr.length; i += 1) {
    arr[i] += 1;
  }
  return arr;
}

const tmp = fn(nums[0]);

console.log(nums.flatMap((a) => a)); // [2, 3, 4, 4, 5, 6]
console.log(tmp); // [2, 3, 4]
```

이렇게 주소를 참조하는 로직의 경우 충분하게 문제가 될 수 있다.

## 계층형 설계

중간 중간 문제가 많아서 재밌었다.

이 설계는 추상화 수준과 호출하는 순서에 따라 함수들을 계층으로 나눈다.

`Array.map` 같은 가장 낮은 추상화 단계의 언어 자체의 함수부터, 이 함수들을 계속 중첩해 실행해나가는 것을 그리며 설계하는 것을 계층형 설계라고 한다.

![image](https://github.com/vinitus/my-blog/assets/97886013/96c9766e-0d0f-4fa1-a5a4-2a9e97bbf32f)

이런 식으로 나눠진다고 생각하면 될 것 같다.

모든 함수가 저렇게 같은 층에만 있진 않는다. 더 많은 계층이 있을 수 있고, 화살표는 어떤 계층을 건너뛰게 될 수도 있다.

책에서는 이런 것을 통해서, 함수형 프로그래밍의 감을 잡는 것이라고 한다. 그러면서도, 완벽한 다이어그램은 존재하지 않으니, 여기에 몰입할 필요는 없고 다른 개발자와 이야기하기 위한 도구로써의 가치도 생각하라고 한다.

### 추상화 벽

이 파트를 읽으며 가장 와닿았던 것은 추상화 벽이다. 다른 파트나 우리의 코드 들 중에서 우리가 만들어야하는 기능의 대한 것을 함수 하나로써 소통하는 것이다.

이는 API는 하나의 추상화 벽이며, 우리는 이 API의 내부 구조에 대한 이해와는 상관 없이 원하는 기능이나 데이터를 얻기 위한 것이다. Open API나 `Array.map`도 추상화 벽에 해당한다고 생각한다.

추상화 벽을 사용하면, 팀 간의 조율에 있어서 많은 것들을 생각하지 않고 주어진 문제에 집중할 수 있다. 어떤 함수의 인자를 `Array`형태로 받고 있었는데, 시간 복잡도 문제로 인해 `Array`를 `Object`로 바꾸게 되었다고 해보자. 그럼, 다른 팀에서 해당 배열을 전부 `Object`로 바꿔야할까?

아니다. 이 `Array`를 `Object`로 바꾸는 **Copy On Write**를 사용하면 된다. 이를 통해서, 다름 팀이나 팀원에게 "성능상의 문제로 해당 함수를 Object로 바꿨으니 앞으로는 Object를 사용하셔야만 합니다."라고 PR을 날리지 않아도 되고, 불필요한 버그를 만들지않아도 된다.

이것이 추상화 벽이 가진 힘이다. 그만큼 이 계층에 어떤 함수를 생성할 때에는 조심해야한다. 여기에 놓일 함수는

1. 코드가 적어야하고
2. 인터페이스가 작어야 한다.

라고 느꼈다.

1. 코드가 적어야하는 이유

여기에 많은 로직과 코드가 담길수록, 후에 코드를 변경해야할 때 많은 시간이 소요된다. 로직을 고치는데에도 더 많은 시간이 들어가고, 이를 다시 이해하는데도 시간이 많이 들어간다.

2. 인터페이스가 작아야하는 이유

이 인터페이스에 너무 많은 기능을 담게 된다면, 이 함수를 사용하기 위해서 많은 것들을 알아야한다. React와 Next.js를 생각해보면 괜찮을 것 같은데, 결국 이는 러닝 커브의 문제라고 생각한다. 많은 기능을 달면 배우는데 오래 걸리지만, 그만큼 강력한 기능을 가진다.

하지만, 추상화 벽에 있는 일반 함수들을 사용하는데 있어서 이런 것을 알아야할까? 만약에 해당 함수가 너무 오래걸린다면, 많은 기능 중 일부만 필요한다면, 알아야하는 인자가 너무 많다면 문제가 생길 것이다.

### 편리한 계층

책에서는 이런 계층도 있다고 한다. 이 책이 말해왔던 모든 계층이나 지침을 무시한 채, 문제를 해결하는데 목적을 두는 계층이 필요하다고 한다.

생각해보면, 변하지 않을 코드는 없을 것이라고 생각한다. React처럼 잘 만든 프레임워크는 몇년째 잘 작동하는 일부분의 코드 그대로가 유지되고 있지만, 대부분의 코드는 진화한다.

- 클래스 기반으로 움직이던 React가 Hook과 함께 함수형 컴포넌트를 도입한 것처럼
- UI에만 집중하던 React가 data fetching을 위한 여러 개념들을 만든 것처럼
- Client Component에서 Server Component를 만든 것처럼
- `use` 훅을 만들어, Client 컴포넌트에서의 비동기 핸들링을 만든 것처럼

React도 진화하며 코드들도 진화한다.

이런 것처럼, 우리가 만든 함수들도 변화하고 진화할 것이다. 요구 사항이 변경될 수도 있고, 더 나은 방법이 생각날 수도 있다.

그럼 일단 함수형 프로그래밍으로 만들지 않고, 추상화 벽 같은 계층형 설계를 따르지 않고, 일단 만들고 보는 것이다. 그 다음, 너무 지저분하거나 함수의 실행을 위해 너무 많은 것들을 알아야만 한다면, 다시 패턴을 적용하여 차근차근 리팩토링하라고 한다.

> 어떤 코드도 이상적인 모습에 도달할 수 없습니다. 언제나 설계와 새로운 기능의 필요성 사이 어느 지점에 머물게 됩니다. 편리한 계층은 언제 멈춰야 할지 알려줍니다. 여러분과 팀은 코드를 가지고 일을 하면서 개발자로서의 필요성과 비즈니스 요구사항 모두를 만족시켜야 합니다.
> 출처 : 쏙쏙 들어오는 함수형 코딩

### 계층형 설계가 지향하는 코드

책을 읽으면서 예전에 배민 기술 블로그인가? 에서 단일책임 원칙에 대해 들었던 기억이 있다. 거기서도 책에 내온 코드와 매우 유사했다.

```javascript
function fn1(a, b) {
  return fn2(b, () => fn3(a));
}
```

이렇게 하나의 함수에 하나의 기능만 사용하라고 했던 것이 기억난다. 그 함수는 하나를 초과한 둘 이상의 책임을 지게 되면, 테스트나 리팩토링이나 디버깅에서 과도한 시간이 소요될 수 있다고 한다.

근데, 또 다른 팀에서 버그난 것을 고치는 걸 도와준 적이 있는데.. 이렇게 단일 책임 원칙으로 코드를 짰다가 오히려 디버깅하는데 고생했던 기억이 있다. 오히려 읽기 힘들었다. 왜 A -> A' -> B를 하는지 잘 이해가 안갔던 코드도 있었고, 중개함수라고 볼 수 있는 함수까지는 위의 코드처럼 짰는데, 정작 중요한 로직은 중첩된 코드와 전역 변수 사용으로 인해서 읽기 힘들었던 기억이 있다... 이런 코드를 작성하려면 생각하고 조심하면서 JS DOC을 사용하는 것이 좋아보인다.
