마크다운 기능을 완성하면서, 이것저것 생각하면서 다시 코드를 적어가다보니 이 책이 이제는 이해갈 것 같아서 읽기 시작 8/29 ~

원래는 나는 코드를 길게 만들면서, 그리고 함수를 이것저것 실행해가며 콜 스택을 어지럽히는게 과연 무엇이 좋을까? 성능적으로도 별로지 않을까? 생각했다.

그러디 FormFilter 컴포넌트의 로직과 백틱 알고리즘을 구현하면서 이제는 왜 사용해야하는지를 알게 될 것 같다.

이 마크다운 파일에서는 책의 정리보다는 내가 느끼고 찾아본 것들이 주류가 될 것 같다.

# 함수형 프로그래밍

함수형 프로그래밍에서는 수학적 함수인 순수 함수가 주류가 된다. 늘 언제나 같은 값을 받으면, 같은 결과가 나와야하는 것이다.

이를 프로그래밍으로 끌고온다면, 전역 변수를 사용하지 않아야 한다. 어떤 곳에서든 호출하면 언제나 같은 결과가 나와야한다. 이를 위해서는 부수 효과들을 빼야한다. `React`에서도 서버의 데이터를 받아오는 등의 행위를 useEffect 훅으로 묶어서 side effect(부수 효과)로 처리하고 컴포넌트 자체는 상태와 UI만을 위한 함수로 작동한다. 이처럼, 순수 함수도 side effect를 피하려고 한다.

하지만, 지금 말하려는 함수형 프로그래밍은 실제 프로덕션에서 사용하는 프로그래밍 패러다임 중 하나이다. 이는 반드시 side effect들이 포함되어야만 한다. 예를 들어 DB의 데이터를 읽어온다거나, HTTP 요청을 보내는 등의 작업이 side effect에 포함된다.

그래서 사전적 정의와 프로그래머가 사용하는 프로그래밍 패러다임으로써의 함수형 프로그래밍은 조금 다르다. side effect를 없앨 수 없기에 조심히다루고, 로직으로 부터 분리해낼 수 있는 순수 함수들을 분리하는 방식이 함수형 프로그래밍이다.

## 액션, 계산, 데이터

나는 처음 이 부분을 읽을 때, 왜 이렇게 나누는지 공감이 잘 되지 않았다. 액션을 최대한 분리하는 것이 무엇이 의미가 있을까? 액션이 계산을 오염시킨다고 해서 문제가 될게 있을까? 싶었다.

하지만 이제는 알 것 같다. 백틱 알고리즘을 테스트할 때, 여러 테스트 케이스들을 마크다운에 적고 실제로 적용해가며 테스트한 적이 있다. 그런데 나는 이제 하나의 함수에 반복문이나, 조건문들을 중첩하고 넣다보니 어디서 잘못된 방향으로 흘러가는지 몰라서 console.log를 10줄은 넘게 작성했던 것 같다.

그리고 리팩토링이 쉽다는 말은, 이미 여러 번의 함수형 프로그래밍이 아닌 직접 구현으로써 react프로젝트를 겪으며 느꼈던 것이다.

**전역 변수 사용에 대한 경고**

내가 이해한 책의 권고사항은, 외부 스코프를 참조하지 않는 것을 권하고 있다. 최대한 순수 함수로써 작성하라는 것이다. 처음에는 잘 이해가 가지 않았다. 적절하게 사용하면 이만큼 편한게 없는데?
그런데 이 부분을 읽고 컴포넌트를 리팩토링했던 일이 생각났다. 컴포넌트 안에서 어떤 함수를 만듬으로 인해서, 그 함수에서는 자연적으로 잘 사용했던 state나 setState들을 자연스럽게 사용했고 문제는 없었다. 그러다가 함수를 밖으로 빼내고, 상태를 관리하는 것을 props로 옮겨야했던 일이 있었다. 이때 좀 고생했던 기억이 난다. 귀찮더라도 함수들을 순수 함수로써 잘 했었다면 더 쉽고 편했을 것이다.

## 항상 인자를 받은 데이터를 복사해서 사용하기

이것도 처음에는 잘 이해가 가지 않았다. 이것도 근데 eslint에서 유명한 약속 중 하나이다. `no-param-reassign`

인자로 받은 데이터를 재할당하는 것은 코드의 가독성이나 유지보수에 좋지 않다. 그리고 만약, 이 인자를 그대로 사용해야만 하는 코드가, 재할당 이후에 이뤄진다면 코드를 어떻게 해야할지 충분히 문제가 될 수 있다고 생각한다.

그리고 원치 않는 문제가 생길 수 있다.

그나마 문제가 될만한 코드?

```javascript
const nums = [[1, 2, 3], [4, 5], [6]];

console.log(nums.flatMap((a) => a)); // [1, 2, 3, 4, 5, 6]

function fn(arr) {
  for (let i = 0; i < arr.length; i += 1) {
    arr[i] += 1;
  }
  return arr;
}

const tmp = fn(nums[0]);

console.log(nums.flatMap((a) => a)); // [2, 3, 4, 4, 5, 6]
console.log(tmp); // [2, 3, 4]
```

이렇게 주소를 참조하는 로직의 경우 충분하게 문제가 될 수 있다.
